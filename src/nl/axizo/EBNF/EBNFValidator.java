/**
 * $Id$
 *
 */
package nl.axizo.EBNF;

import nl.axizo.parser.*;
import java.util.Vector;
import java.util.Map;
import java.util.Hashtable;


/**
 * Perform validations on the parse tree, as generated by the
 * EBNF parser.
 *
 * This class is used between the parse step (in which an input
 * file is converted to a parse tree) and the translation step (in
 * which output is generated from the parse tree). 
 *
 * The goal is to check if the input tree conforms to rules which
 * are not enforced by the syntax
 */
public class EBNFValidator {

	public void validate( State state ) throws ParseException {
		Util.info("Validating...");

		Node root = state.getCurNode();

		//All actions must have a corresponding rule
		Vector actions = collectActionLabels( root);
		Map    rules   = collectRuleLabels( root);
		for( int i = 0;  i < actions.size(); ++i ) {
			String label = (String) actions.get(i);

			if ( rules.get( label ) == null ) {
				throw new ParseException( "Action '" + label + "' does not have a corresponding rule.");
			}
		}
	}


	private Vector collectActionLabels(Node root) {
		Vector ret = new Vector();

		Vector res =  root.findNodes( "action" );
		for( int i = 0;  i < res.size(); ++i ) {
			Node n = (Node) res.get(i);

			String actionName = n.get("label").getValue();
			ret.add( actionName);
		}

		return ret;
	}

	private Map collectRuleLabels(Node root) {
		Map ret = new Hashtable();

		Vector res =  root.findNodes( "rule" );
		for( int i = 0;  i < res.size(); ++i ) {
			Node n = (Node) res.get(i);

			String ruleName = n.get("label").getValue();

			// only key presence is important, value is something not null.
			ret.put( ruleName, "1");
		}

		return ret;
	}

}

