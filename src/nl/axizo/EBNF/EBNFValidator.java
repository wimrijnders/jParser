/**
 * Copyright 2012 Wim Rijnders <wrijnders@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 *=========================================================================
 */
package nl.axizo.EBNF;

import nl.axizo.parser.*;
import java.util.Vector;
import java.util.Map;
import java.util.Hashtable;


/**
 * Perform validations on the parse tree, as generated by the
 * EBNF parser.
 *
 * This class is used between the parse step (in which an input
 * file is converted to a parse tree) and the translation step (in
 * which output is generated from the parse tree). 
 *
 * The goal is to check if the input tree conforms to rules which
 * are not enforced by the syntax
 */
public class EBNFValidator extends Validator {

	private Vector errors = new Vector();


	protected void addError(String msg) {
		errors.add( msg );
	}


	private boolean hasErrors() {
		return (errors.size() > 0);
	}


	private String allErrors() {
		String out = "";

		for( int i = 0; i < errors.size(); ++ i ) {
			out += "\t" + errors.get( i ) + "\n";
		}

		return out;
	}


	public void validate( State state ) throws ParseException {
		Util.info("Validating...");

		Node root = state.getCurNode();

		Vector actions = collectActionLabels( root);
		Map    rules   = collectRuleLabels( root);

		// Rightlabel must be defined as rules
		Map    rlabels = checkRightLabels(root, rules);

		//All actions must have a corresponding rule
		for( int i = 0;  i < actions.size(); ++i ) {
			String label = (String) actions.get(i);

			if ( rules.get( label ) == null ) {
				addError( "Action '" + label + "' does not have a corresponding rule.");
			}
		}

		// All rules should be used somewhere, unless they are
		// an entry point or WS
		// TODO: Consider making this an error.
		String [] rulenames = (String []) rules.keySet().toArray( new String[0] ) ;
		for( int i = 0;  i < rulenames.length; ++i ) {
		
			// Special case WS has default definition - not compulsory
			if ( "WS".equals( rulenames[i] ) ) continue;
	
			String value = (String) rules.get( rulenames[i] );
			if ( "entry".equals( value ) ) {
				// It's an entry point - ignore
				continue;
			}

			if (!rlabels.containsKey( rulenames[i] ) ) { 
				addError( "Rule '" + rulenames[i] + "' not used anywhere.");
			}
		}
		
		// We're done. Report errors if any
		if ( hasErrors() ) {
			throw new ParseException( "Errors found during validation:\n" + allErrors() ); 
		}
	}


	private Vector collectActionLabels(Node root) {
		Vector ret = new Vector();

		Vector res =  root.findNodes( "action" );
		for( int i = 0;  i < res.size(); ++i ) {
			Node n = (Node) res.get(i);

			String actionName = n.get("label").getValue();
			ret.add( actionName);
		}

		return ret;
	}


	private Map collectRuleLabels(Node root) {
		Map ret = new Hashtable();

		Vector res =  root.findNodes( "rule" );
		for( int i = 0;  i < res.size(); ++i ) {
			Node n = (Node) res.get(i);

			String ruleName = n.get("label").getValue();

			// rules should be present exacly once
			if ( ret.containsKey( ruleName ) ) {
				addError( "Rule " + ruleName + " present more than once.");
			} else {
				String value = "1";

				if ( !n.get("rule_modifier").get("string").isNull() ) {
					if ( "entry".equals( n.get("rule_modifier").get("string").getValue() ) ) {
						// It's an entry point
						value = "entry";;
					}
				}

				ret.put( ruleName, value);
			}
		}

		return ret;
	}


	/**
 	 * Check for existence of rightlabels.
 	 *
 	 * The definition of rightlabels is the rule names
 	 * used in the right hand side of rules. These should
 	 * be names of existing rules.
 	 */
	private Map checkRightLabels(Node root, Map rules) throws ParseException {
		Util.info("Validating rightLabels.");

		Vector rightLabels = new Vector();

		Vector res =  root.findNodes( "statement" );
		for( int i = 0;  i < res.size(); ++i ) {
			Node n = (Node) res.get(i);

			// Filter out the right-labels from the statements
			if( !n.get("label").isNull() ) {
				rightLabels.add( n );
			}
		}

		// Scan all rightlabels for existence of corresponding rules.
		for( int j = 0;  j < rightLabels.size(); ++j ) {
			Node n = (Node) rightLabels.get(j);
			String label = n.get("label").getValue();

			if ( !rules.containsKey( label ) ) {
				// rightlabel not defined as rule; flag error.
				// As extra info, supply the rule name under which
				// this rightlabel was used.
				addError("Righlabel '" + label + "' "
						+ "in rule '" + getParentRuleName( n ) + "' "
						+ "is not defined as a rule.");
			}
		}

		// As a side effect, generate a map of all rightlabels
		Map ret = new Hashtable();
		for( int i = 0;  i < rightLabels.size(); ++i ) {
			Node n = (Node) rightLabels.get(i);
			String label = n.get("label").getValue();

			ret.put( label, "1");
		}

		return ret;
	}


	/**
 	 * Retrieve the rule name under which passed statement Node is defined.
 	 *
 	 * @param n statement node containing rightlabel.
 	 */ 
	private String getParentRuleName(Node n ) throws ParseException {
		String rightlabel = n.get("label").getValue();
		String out = null;

		while( out == null ) {
			n = n.getParent();

			if ( n == null ) {
				// Hit the top of the parse tree, shouldn't happen
				throw new ParseException( "Encompassing rule not found for rightlabel '" 
						+ rightlabel + "'.");
			} 

			if ( "rule".equals( n.getKey() ) ) {
				// found the rule. Return the rule name
				out = n.get("label").getValue();
			}
		}

		return out;
	}
}

