#######################################################################
# $Id$ 
#
# For reserved words#characters till now, view the language definition.
#
#######################################################################
# Output in general:
#
# header
# class declaration
# {
#    internal ParseBlock() routines
#    internal helper routines
#    state variables 
#    function declarations
# }
#
# global parser object
# main()
# member functions of parser class
# Listing of final attribute tree
# [end-output]
#
#######################################################################
# Output from EBNF definitions:
#									
# Logically a list of functions with the following layout:
#
# header: BOOL Parse_(is)
# {							
#    Local declarations   : fconst
#    pre-Action block
#    Parsing block     : fbody
#    post-Action block
#    return TRUE;
# }
#
#######################################################################
# Precedence, highest to lowest:
#    ( )   - overrides all
#    [],{}
#    '|'   - left to right
#######################################################################
# NOTES:
# ======
#
# * Use of BUILD an BOOTSTRAP version numbers:
#
#   There is a subtle difference for the two version numbers I use for
#   this file. One does not exclude the other, nor does it demand an
#   update of the other. 
#
#   - BOOTSTRAP: If the language changes to such an extent that I had to use
#     the bootstrapped version of the parser to make it work properly, I raise 
#     this version number by one ( eg. a new keyword is added). In a sense, this
#     statement is contradictory: how can you make the bootstrap if you don't
#     have the bootstrapped version? Don't you just love bootstrapping?
#
#   - BUILD: this version number is incremented if I make an adjustment in the
#     supporting code (eg. add extra functionality or solve a bug).
#
#   Having said all this, I usually don't bother with version numbers for
#   minor changes.
#
#######################################################################

#TEST: using language file ebnfdef.ebnf.

language EBNF
{
noWS
ignore SetError      = "Err" [+\-].
token modifier_WS   =  "skipWS" | "noWS".
SetCase       = "matchCase" [+\-].
skip switches      = SetError | modifier_WS | SetCase.
o_comment     = Err+ "#" { [\all~\r\n] } [\r\n].
c_comment     = Err- "//" { [\all~\r\n] } [\r\n].
token comment       = o_comment | c_comment.
ignore WS     = { comment | [ \t\n\r] }.

//Character definitions
overridechar  = [\)\-\~\\\]].               
# except clause on statement level not handled yet.
# except part in following range is actually overridechar
# ORIGINAL:
# token any     = [\all]~overridechar.
token any     = [\all~\)\-\~\\\]].               
dec           = [0123456789].
ExtChar       = [rnt] | overridechar | (dec dec dec) .
anychar       = any | ( "\\" ExtChar). 

//Definitions EBNF extensions 
csallchars    = "\\all".
token range       = csallchars | ( anychar  ( "-"  anychar )?  ).

except_charset= '~' range+.
charset       = noWS '[' {  range+ | except_charset }  ']'.
                            

litchar       = [\all~'"\r\n\\] 
                | ( '\\' ['"\\trn] ).     

token LiteralBlock  = litchar+.      

# literal_symbol-s are meant for the string which are part of the grammar.
# They usually don't show up in the final parse result.
# The exception (till now) is the parser itself - it should be able to handle
# the literal_symbol-s.
#
# Under normal circumstances, following should have line modifier 'ignore'.
token literal_symbol = '\'' LiteralBlock '\''.

# Literals are strings which contain information relevant to output, such as
# parts of labels.
token literal        = '\"' LiteralBlock '\"'.

token label   = [_a-zA-Z] [_a-zA-Z0-9]*.

skipWS

//Basic WEBNF stuff
skip basicstatement = charset | literal| literal_symbol | label.
group          = statements.
ConditionalSeq = statements.
repeat         = statements.

token postfix     = [+*?].

ExceptStatement= statement.
statement      = 
		( '{' repeat '}' ) |
		(
			( basicstatement  | ( '(' group ')' ) ) 
			noWS ( postfix | ('~' skipWS ExceptStatement) )?
		).

alternative   = statement  ( '|'  statement)*.
statements       = (switches* alternative)+.

rule_modifier  = 'entry' | 'ignore' | 'token' | 'skip'.
rule           = rule_modifier? label Err- '=' Err+ statements '.' .

#
#The actual language definition
#

skip languageblock  = 'language' label '{' 
		{ switches | State | action | function | rule } 
	'}'. 

usingfile      = noWS [a-zA-Z0-9_]+ ( [.] { [a-zA-Z0-9_] } )?.
languagefile   = Err- "using"  "language" "file" usingfile ".".
includefile    = "using"  "include" "file" usingfile ".".

#Entry point - note that there should not be more than one main-block
entry language = {languagefile|includefile}  languageblock {languagefile} main?  {languagefile}.

#
# Macro blocks (actually part of action blocks)
#

noWS
TS             = [ \t]+.                #TabSpace
macrochar      = [a-zA-Z0-9_].
macroid        = macrochar+.
varname        = macroid.
realpathname   = macroid.
var_start      = '['.
var_end        = ']'.
pathname       = realpathname 
                | ( var_start (macro_currenttoken|varname) var_end ).	  
                #NOTE: order important in second '\|'

set_dot        = "!".
get_dot        = ".".
set_path       = set_dot pathname.
get_path       = get_dot pathname.
abs_path       = get_path | set_path.
rel_path			= varname.
macro_path     = abs_path | rel_path { get_path | set_path }.

attrpoint      = macroid.
macro_foreach  = 'foreach' TS attrpoint TS 'in' TS macro_path.
macro_body     = 'body'.
macro_forend   = 'end' noWS TS 'foreach'.

macro_currenttoken = 'CurrentToken'.

macro_start    = '$'.
macro_end      = '$'.
macro_block    = macro_start (
		macro_foreach | 
		macro_body|  
		macro_forend | 
		macro_currenttoken |
		macro_path 
	) macro_end.

skipWS


#
#Action blocks:
#
noWS
#Note explicit removal of '0' in override chars - to catch any hex or oct
blocklitchar   = [\all~"\r\n\\] | ( "\\" [\all~0] ).      
blockstring    =  "\"" { blocklitchar } "\"".

#Order important in following
ignore block_comment = o_comment.
blockchar      = c_comment | block_comment | blockstring | [\all~{}$].  
token code_block     = { ( "{" code_block "}" ) | blockchar | macro_block }.
skipWS

ignore pre_indicator = "pre:". 
ignore post_indicator = "post:". 
#token 
pre_block  = pre_indicator  '{' noWS code_block '}'.
#token 
post_block = '{' noWS code_block '}'.

action    = 'action' label  (pre_block ( post_indicator post_block )? ) | post_block.

#
# Functions
#

funcchar       =  [_a-zA-Z0-9].
token funcid   = noWS funcchar+.
#token reference= "&".
#token pointer  = "*".
#functype       = funcid ( pointer | reference )?.
functype       = funcid ( "*" | "&" )?.
token funcvar        = funcid.
token funcname = funcid.
token returntype     = functype .
parameter      = functype funcvar.
paramlist = '(' ('void' | ( parameter { ',' parameter } ) )? ')'.
skip funcheader     = returntype funcname  paramlist.
function       = 'function' funcheader '{' noWS code_block '}'.

#
# State and main
#

# Definitions state extended, to allow for proper definition of constructor
token number   = Err- noWS ( '+' | '-' )? dec+.
token type_state = "WCLabels" | "WCString" | "int" | "charset" | "bool".
token member_state = label.
oldbool         = "TRUE" | "FALSE".
token param_init = number | oldbool | "true" | "false".
token ctor_init      = '(' param_init ')'.
statevar       = type_state member_state ( ('=' param_init ) | ctor_init  )?.
stateblock     = { statevar ';' }.
skip State     = 'state'  '{' stateblock '}' . 
main           = 'int main(int argc, char *argv[])'  '{' noWS code_block '}' .


///////////////////////////////////////////////////////////////
// State Block
///////////////////////////////////////////////////////////////

state
{
   //Storage vars for parsed data
   WCString gLastValue;                 //Last label parsed             
   
   bool     gSkipWS         = true;     //TRUE if whitespace should be parsed (ie. it is skipped) in parser output, 
   bool     gDefaultWS      = true;     //FALSE if there is no whitespace in parser output
   bool     gDefaultErr     = true;
   bool     gDoErr          = true; 

   bool     gDefaultCase    = true;     //TRUE if compares should be case-sensitive, else FALSE.
   bool     gMatchCase      = true;             
   
   bool     gDoingLine;                 //True if parsing Line (see EBNF), False if parsing anything else (including WS)

   //vars for parsing charsets
   int		m_charsetCount;     		//Counter for class-level charsets
   charset  tempcharset;
   bool     m_bCharsetHasZero;          //TRUE if there's a '\0' in charset
   bool     do_insert;

   bool     gDoneStateBlock;            //TRUE if state block found
   bool     gDoneMainBlock;             //TRUE if main block found
   WCString gMainBlock(256);
   int      m_BlockCount = 0;

   WCLabels m_stateVarAcc(256);         //Collect buffer for state variables.

   bool     m_bEntryPoint;

   WCString m_macroblock;
   WCString m_attrpoint;
   int      m_nRootcnt;

   bool m_bDoingDefinition;
   bool m_bDoingImplementation;
        
        bool m_bIgnoreActive;
        bool m_bTokenActive;

        bool m_bUsesCurrentToken;

        //Following var' are actually local to action alternative 
        WCString alternative_thisValue;
        int alternative_bLastWasLoop;
        int alternative_bLastWSval;
}


///////////////////////////////////////////////////////////////
// Action Blocks
///////////////////////////////////////////////////////////////


action SetError 
{
   bool thisvalue = ($CurrentToken$ == "+");
   
   if (!gDoingLine) gDefaultErr = thisvalue;
   gDoErr = thisvalue; 
}


action SetCase 
{
   bool thisvalue = ($CurrentToken$ == "+");
   
   if (!gDoingLine) 
      gDefaultCase = thisvalue;

   gMatchCase = thisvalue;

   ParseError("Detected Case!",WARNING); 
}


action o_comment
{
        #ignore value entirely
#	$CurrentToken$.empty();
        setCurrentToken("");
}


action ExtChar
{
   static bool sbDidZeroWarning = false;

   if ( 1 == $CurrentToken$.Length() ) {
      //
      //It must be a special override character - replace by proper char value
      //    if necessary
      //
                switch ( *($CurrentToken$.GetBuf()) ) {
                        case 'r': setCurrentToken('\r'); break;
                        case 'n': setCurrentToken('\n'); break;
                        case 't': setCurrentToken('\t'); break;

                        //ignore all others (syntax checked out, so must be OK)
                        default:  break;
                }
   }
   else
   if ( 3 == $CurrentToken$.Length() ) {
      //
      //It must be a decimal - try to convert
      //
      int returnval = atoi($CurrentToken$.GetBuf());
      if (!returnval) {
         //Check for zero
         if (  $CurrentToken$ != WCString("000") ) {
            return ParseError("Decimal number expected for Label ExtChar",ERROR);
         }
         else {
            //it is really a zero - increment by 1 to avoid conflict with string terminator
            ++returnval; 
            m_bCharsetHasZero = true;

            if (! sbDidZeroWarning ) {
               ParseError("Remember: Zero replaced by \'\\1\' in Label ExtChar\n"
                          "\t(This warning is shown only once)",NOTE); 
               sbDidZeroWarning = true;
            }
         }
      }              

      //Replace string by decimal char
#	  $CurrentToken$ = (char) returnval;
                setCurrentToken( WCString((char) returnval) );
   }
   else {
      ParseError("Number of correctly parsed chars should be 1 or 3 for Label ExtChar",WARNING); 
   }
}
 

action csallchars
{
   //Make a complete charset for action range to handle.
   m_bCharsetHasZero = true;
#   $CurrentToken$ = WCString( "\x01\xff" );
   setCurrentToken( WCString( "\x01\xff" ) );
}


action usingfile
{
        #usingfile should now be in CurrentToken
        WCString msg("Usingfile: " );
        msg << $CurrentToken$;
        ParseError(msg,NOTE);
}

action includefile
{
        #Remember filename to include 
        #include files are technically independent of the language to be parsed,
        #so they should NOT be stored as  part of the language specification

        #usingfile should now be in CurrentToken
        $!includefiles$.AddTail($CurrentToken$, "Include");
}


action languagefile 
{
        #usingfile should now be in CurrentToken
        WCString noteString("Including file \'");
        noteString << $CurrentToken$ << "\'";
        ParseError(noteString, NOTE);
        f.openPush($CurrentToken$);
}


action rule
{
        if ( !m_bDoingDefinition && m_bDoingImplementation) {
           static int count = 0;

           if ( 0 == count++ ) {
              ParseError("One or more Rules/patterns detected in implementation part",ERROR);
                }
        }

   Block_Down();
   Tabs.Dec();
   gDoingLine = false;
}


action basicstatement 
{
   SetLoopType("SIMPLE");
}


action ExceptStatement
pre:
{
   $!alternateAccStack$.Push("newval");
   $!alternateAccStack.newval$ = $.alternateAcc$;	//Note that name of newval also changes!!!
   $.alternateAcc$.ClearAttributes();
}
post:
{
          ParseError("Exception encountered",NOTE);

        //$.alternateAcc.list$ now contains the except statement list (which must have exactly one item!!!)
        //Add this list as an exception clause to the last parsed statement

        if ( $.alternateAccStack.alternateAcc.list$.HasAttributes() ) {
                CAttributeTree *pAttributes = $.alternateAccStack.alternateAcc.list$.GetAttributes(); 
                pAttributes->MoveLast();

                if ( $.alternateAcc.list$.HasAttributes() ) {
                        $.alternateAcc.list$.GetAttributes()->Top( pAttributes->GetCurrent()->Set("exception").Set("newval" ) );
                }
                else {
                  ParseError("Expected attributes for alternateAcc in ExceptStatement.",ERROR);
                }
        }
        else {
          ParseError("Expected attributes for alternateAccStack in ExceptStatement.",ERROR);
        }

   //Restore original statement
   $.alternateAcc$ = $.alternateAccStack.alternateAcc$;
   WCString dummy;
   $.alternateAccStack$.Pop(dummy);
}


action ConditionalSeq 
pre:
{
   if ( gSkipWS && ! LastWasLoop() && !IsFirstInFunction() ) {
          fbody() << Tabs << "SkipWS();";
        }

   fbody() << Tabs << "do  { //Start conditional block";
                       //!
   SetFirstInFunction(TRUE);
   Tabs.Inc(); 
   SetInLoop();
}     
post:
{
   if ( gSkipWS ) {
          fbody()  << Tabs << "SkipWS();";
        }

   Tabs.Dec();
   fbody() << Tabs << "} while (FALSE); //End conditional block\n";
   SetLoopType("LOOP");
}


action pre_indicator 
{
        #ignore result
#	$CurrentToken$.empty();
        setCurrentToken("");
}


action post_indicator 
{
        #ignore result
#	$CurrentToken$.empty();
        setCurrentToken("");
}


action pre_block
pre: {
        m_bUsesCurrentToken = false;
}
post: {
   if ( !$.language.[gParserLanguage].Labels.[gLastValue]$.Exists() ) {
       return ParseError("Label not defined; can't create pre-action block.",2);
   }
  
   if ( m_bUsesCurrentToken ) {
           ParseError("CurrentToken used in pre-block; contents are always empty.",ERROR);
   }

   //Store label at designated spot
  $.language.[gParserLanguage].Labels.[gLastValue]!pre$.SetValue($CurrentToken$);
}


action post_block
pre: {
        m_bUsesCurrentToken = false;
}
post: {
   if ( !$.language.[gParserLanguage].Labels.[gLastValue]$.Exists() )
      return ParseError("Label not defined; can't create post-action block.",2);

   if ( m_bUsesCurrentToken ) {
      $.language.[gParserLanguage].Labels.[gLastValue]!currentToken$;
   }
  
   //Store label at designated spot
        $.language.[gParserLanguage].Labels.[gLastValue]!post$.SetValue($CurrentToken$);
}


action action 
{
   //W11-3-97 Check if at least one block defined
   if ( !( $.language.[gParserLanguage].Labels.[gLastValue].pre$.Exists() ||
           $.language.[gParserLanguage].Labels.[gLastValue].post$.Exists() ) )
      return ParseError("Label does not have pre- or postaction block.",2);

    if ( m_bDoingDefinition && !m_bDoingImplementation) {
           static int count = 0;

           if ( 0 == count++ )
                  ParseError("One or more Action blocks found in definition part.",ERROR);
    }
}


action State 
{
   if ( m_bDoingDefinition && !m_bDoingImplementation)
      ParseError("State block found in definition part.",ERROR);

   //All went OK -> store state in global buffer
   if ( gDoneStateBlock) {
      ParseError("Already parsed a State_block!\n",ERROR);
   }
   else {
      gDoneStateBlock = true;
   }
}


action main
{
   //All went OK -> store main in global buffer
   if ( gDoneMainBlock) {
          ParseError("Already parsed main()!", WARNING);
        }
   else {
      gMainBlock = $CurrentToken$;
      gDoneMainBlock = true;

          $!settings!mainblock$.SetValue(gMainBlock);
    }
}


action member_state
{
        //W15-12-96 the Cast to reference in the following line is to ensure that 
        //          member WCString objects in m_stateVarAcc are not overwritten.
        WCString &tempVarAcc = m_stateVarAcc;
        tempVarAcc = $CurrentToken$;
}


action type_state
{
   m_stateVarAcc.pre_action = $CurrentToken$; //used for member type
}

action oldbool
{
        static bool bShowedWarning = false;

        if ( !bShowedWarning )	{
                WCString msg = "'TRUE'/'FALSE' considered obsolete; use 'true'/'false' instead.\n"
                                           "\t(This warning is shown only once)";
                ParseError( msg, NOTE);
                bShowedWarning = true;		
        }
}

#
# Macro block actions
#

action attrpoint
{
   m_attrpoint = $CurrentToken$;
}


action realpathname
{
   #Can't use << in following
#   $CurrentToken$ = WCString("\"") +  $CurrentToken$ + WCString("\"");
   setCurrentToken(  WCString("\"") +  $CurrentToken$ + WCString("\"") );
}


action var_start
{
        #ignore value
#	$CurrentToken$.empty();
        setCurrentToken("");
}


action var_end
{
        #ignore value
#	$CurrentToken$.empty();
        setCurrentToken("");
}


action set_dot
{
        #ignore value
#	$CurrentToken$.empty();
        setCurrentToken("");
}


action get_dot
{
        #ignore value
#	$CurrentToken$.empty();
        setCurrentToken("");
}


action set_path
{
   if ( !$CurrentToken$.Length() )
      return ParseError("CurrentToken has length zero in action \'set_path\'",ERROR);

#   $CurrentToken$ = WCString(".Set(") + $CurrentToken$ + WCString(")");
        setCurrentToken(WCString(".Set(") + $CurrentToken$ + WCString(")") );

}


action get_path
{
   if ( !$CurrentToken$.Length() )
      return ParseError("CurrentToken is zero in action \'get_path\'",ERROR);

#   $CurrentToken$ = WCString(".Get(") + $CurrentToken$ + WCString(")");
        setCurrentToken(WCString(".Get(") + $CurrentToken$ + WCString(")") );
}


action macro_start
{
   //Get rid of last char ('$')
#   $CurrentToken$.empty();
        setCurrentToken("");
   
   m_macroblock.empty();
}


action macro_end
{
   //Get rid of trailing '$'
#   $CurrentToken$.empty();
        setCurrentToken("");
}


action rel_path {
        setCurrentToken(WCString("(*") + $CurrentToken$ + ")" );
}


action abs_path {
        setCurrentToken(WCString("m_attributes") + $CurrentToken$ );
}

action macro_path
{
   m_macroblock = $CurrentToken$;
}


action macro_foreach
{
   if ( !m_attrpoint.Length() )
      return ParseError("We need an attribute pointer in \'foreach\'",ERROR);

   if ( !m_macroblock.Length() )
      return ParseError("We need an attribute path in \'foreach\'",ERROR);

   WCString pRoot("pRoot");
   pRoot.AddInt(++m_nRootcnt);

        setCurrentToken(
                "\nCAttributeTree *" + pRoot + "= " + m_macroblock + ".GetAttributes();\n"
        + "if (" + pRoot + ") {\n"
        );

   
   $!foreachstack$.Push(pRoot);
   $.foreachstack.[pRoot]$.SetValue(m_attrpoint);

   m_macroblock.empty();
}


action macro_body
{
   WCString pRoot;
   WCString attrpoint;
   
   if ( $.foreachstack$.Top(pRoot) == 0) {
      return ParseError("No value on foreach-stack!",ERROR);
   }

   attrpoint = $.foreachstack.[pRoot]$.GetValue();

   if ( attrpoint == WCString("donebody") ) {
      WCString errstr("Already done body for foreach-block ");
      errstr << "\'" << pRoot << "\'";

      return ParseError(errstr,ERROR);
   }

        setCurrentToken( WCString("\n   ") +
           "for( CAttributeTree::iterator " + attrpoint + " = " + pRoot + "->start(); " + attrpoint + " != " + pRoot + "->end(); ++" + attrpoint + ") {\n"
        );

   //Following signals that we've done this loop
   $.foreachstack.[pRoot]$.SetValue("donebody");
}


action macro_forend
{
   WCString pRoot;
   
   if (! $.foreachstack$.Top(pRoot) ) {
      return ParseError("No value on foreach-stack!",ERROR);
   }

   if ( $.foreachstack.[pRoot]$.GetValue() != WCString("donebody") ) {
      WCString errstr("Macro end foreach: Did not do body for foreach-block ");
      errstr << "\'" << pRoot << "\'";

      return ParseError(errstr,ERROR);
   }

#Code for using iterators (doesn't work yet)
   setCurrentToken( 
        WCString( "   }\n" ) +
         "}\n"
        );

   $.foreachstack$.Pop(pRoot);
}


action macro_currenttoken 
{
  m_bUsesCurrentToken = true;

  //Insert code to use current token (replacing macro name)
  //(:-) Don't you just love this?)
  setCurrentToken( "currentToken()" );
}

                                                                 
action macro_block
{
   if ( m_macroblock.Length() ) {
      //It must have been a path
          setCurrentToken( m_macroblock);
   }
}


//
// Actions for Function definitions
// 

action returntype
{
        gLastValue = $CurrentToken$;
        setCurrentToken("");
}


action funcheader
{
   //gLastValue should contain the return type
   if ( !gLastValue.Length() )
      return ParseError("Return-type of function is empty!",ERROR);

        //'feature': can't put $CurrentToken$ directly into path
        WCString tokenval = $CurrentToken$;
   $!language![gParserLanguage]!functions![tokenval]!returnval$.SetValue(gLastValue);

        gLastValue = $CurrentToken$;
        setCurrentToken("");
}



//
//Functions
//

function BOOL outputAlternateAcc(TabType &Tabs, WCString &actionString)
{
        int tabCount = 0;
        int numItems = ($.alternateAcc.list$.HasAttributes())?( $.alternateAcc.list$.GetAttributes()->GetNumItems() ):0;
        int bDoTabIncrement = FALSE;

        BOOL bIsConditional = FALSE;

         //Output the list
         $foreach pElement in .alternateAcc.list$
         $body$

                //
                // NOTE: repeat postfixes and exceptions exclude each other in the syntax
                //

                //Check for repeat postfixes
                if ( pElement->Get("postfix").Exists() ) {
                        WCString repPostfix = pElement->Get("postfix").GetValue();

                        if ( WCString("+") == repPostfix ) {

                                fbody() << Tabs << "if (";
                                makeFunctionCallFromAlternateAccElement(pElement, FALSE);
                                fbody()	<< ") {";

                                Tabs.Inc();
                                fbody()  << Tabs << "do {";

                                if ( pElement->Get("skipWS").Exists() ) {
                                        Tabs.Inc();
                                   fbody() << Tabs << "SkipWS();";
                                   Tabs.Dec();
                                }

                                fbody()  << Tabs << "} while ("; 
                                makeFunctionCallFromAlternateAccElement(pElement, FALSE);
                                fbody()	<< ");";
                                Tabs.Dec();

                                fbody()  << Tabs << "}" 
                                         << Tabs << "else";

                                bDoTabIncrement = TRUE;
                        }
                        else
                        if ( WCString("*") == repPostfix ) {
                                if ( 1 < numItems ) {
                                        WCString errString;
                                        errString << "Can not use \'*\' postfix in alternative statement";
                                        ParseError(errString,ERROR);
                                }
                                else {
                                        fbody() << Tabs << "while(";
                                        makeFunctionCallFromAlternateAccElement(pElement, FALSE);
                                        fbody() << ") {";

                                        if ( pElement->Get("skipWS").Exists() )
                                           fbody() << "SkipWS();";

                                        fbody() << "}";

                                        bIsConditional = TRUE;
                                }
                        }
                        else
                        if ( WCString("?") == repPostfix ) {
                                if ( 1 < numItems ) {
                                        WCString errString;
                                        errString << "Can not use \'?\' postfix in alternative statement";
                                        ParseError(errString,ERROR);
                                }
                                else {
                                         fbody() << Tabs << "if (";
                                        makeFunctionCallFromAlternateAccElement(pElement, FALSE);
                                        fbody()	<< ") {}";

                                        bIsConditional = TRUE;
                                }
                        }
                        else {
                          static int count = 0;
                          if ( 0 == count++ ) {
                                WCString errString;
                                errString << "Unknown postfix \'" << repPostfix << "\'encountered";
                                  ParseError(errString,ERROR);
                          }
                          return FALSE;
                        }
                }
                else {
                        fbody() << Tabs   << "if (";

                        //
                        //Check for exceptions
                        //
                        // Note that the exceptions are put in front of the regular calls;
                        // this is by design
                        //
                        if ( pElement->Get("exception").HasAttributes() ) {
                                CAttributeNode Exception;

                                pElement->Get("exception").GetAttributes()->Top(Exception);
                                if ( Exception.Exists() ) {
                                        static int count = 0;

                                        makeFunctionCallFromAlternateAccElement(&Exception, TRUE);
                                        fbody() << " || "; 

                                        //Exception found, add to list.
                                        WCString name;
                                        name << Exception.GetName() << " val: " << Exception.GetValue();
                                        $!language![gParserLanguage]!exceptions$.Push(name);
                                }

                                //Check if exception has exception (error - must enclose in braces for this case)
                                if ( Exception.Get("exception").Exists() )
                                   ParseError("Can not catenate except clauses - use ()-braces.",ERROR);
                        }

                        fbody() << "!"; 
                        makeFunctionCallFromAlternateAccElement(pElement, FALSE);
                        fbody() << ")";
                        bDoTabIncrement = TRUE;
                }

                if ( bDoTabIncrement ) {
                        if ( 0 < numItems )
                           fbody() << " {";

                        Tabs.Inc();
                        ++tabCount;
                }
         $end foreach$

        if ( bDoTabIncrement ) {
                fbody() << Tabs << actionString;

                while ( 0 < tabCount ) {
                        Tabs.Dec();
                        --tabCount;

                        if ( 0 < numItems )
                                fbody() << Tabs << "}";
                }
        }

        return bIsConditional;
}


function void makeFunctionCallFromAlternateAccElement(CAttributeNode *pRoot, BOOL doAlternative)
{
        if (!pRoot) {
                ParseError("null pointer passed to makeFunctionCallFromAlternateAccElement().",ERROR);
                return;
        }

        if ( WCString("funccall") != pRoot->GetName() ) {
                ParseError("Expected function call node in makeFunctionCallFromAlternateAccElement().",ERROR);
                return;
        }

        //
        // The function call gets stored as a separate item in the attribute list of the calling function body.
        //

        #Following derived from the output of a $foreach$ loop
        #
        # Following loop copies the alternative values in the value parts of the parameter nodes
        # to the name parts of the nodes. In this way, we don' need to defer the decision to use the
        # alternative values.
        #
        CAttributeTree *pRoot3= pRoot->Get("parameters").GetAttributes();
        if (pRoot3) {
           for( CAttributeTree::iterator pElement2 = pRoot3->start(); pElement2 != pRoot3->end(); ++pElement2) {

                        if ( doAlternative && ( pElement2->GetValue().Length() > 0 ) ) {
                                pElement2->SetName(pElement2->GetValue());
                        }
                        pElement2->SetValue("");
                }
        }


        #Add main node to the end of the fbody list.
        CAttributeTree *pAttributes = $.BlockStack.Block.fbody$.GetAttributes(); 
        pAttributes->AddTail(*pRoot);

        fbodyNewItem();
}


function void SetFirstInFunction(int val )
{
   WCString strval;
   strval.AddInt(val);
   
   $.BlockStack.Block!FirstInFunction$.SetValue(strval);
}


function BOOL IsFirstInFunction()
{
   WCString strval;
   
   strval = $.BlockStack.Block.FirstInFunction$.GetValue();
   return strval.GetInt() != 0;
}


function void SetInLoop()
{
  WCString strval;

  if ( !$.BlockStack.Block.FirstInLoop$.Exists() ) {
     strval.AddInt(1);
    $.BlockStack.Block!FirstInLoop$.SetValue(strval);
  }
  else {
    strval = $.BlockStack.Block.FirstInLoop$.GetValue();
    int temp = strval.GetInt();
    #strval = "";
        strval.empty();
    strval.AddInt( temp +1 );
    $.BlockStack.Block!FirstInLoop$.SetValue(strval);

  }

}


function BOOL IsFirstInLoop()
{
  WCString strval;
  BOOL returnval;

  if ( !$.BlockStack.Block.FirstInLoop$.Exists() )
     return FALSE;

   strval = $.BlockStack.Block.FirstInLoop$.GetValue();
   int temp = strval.GetInt();
   returnval = (temp !=0);
   
   if ( temp > 0 ) temp--; else temp=0;
   strval.empty();
   strval.AddInt( temp );
   $.BlockStack.Block!FirstInLoop$.SetValue(strval);

   return returnval;
}


function void SetLoopType(WCString val)
{
   $.BlockStack.Block!LastStatType$.SetValue(val);
}

function BOOL LastWasLoop()
{
   if ( $.BlockStack.Block.LastStatType$.Exists() &&
        $.BlockStack.Block.LastStatType$.GetValue() == WCString("LOOP") )
      return TRUE;
   else
      return FALSE;
}


function WCString &fconst() 
{ 
   if ( !$.BlockStack.Block$.Exists() ) 
      ParseError("Fatal Error: No blocks defined!",FATAL);

   return $.BlockStack.Block!fconst$.GetValue() ; 
}


function void fbodyNewItem() 
{
        $.BlockStack.Block.fbody$.AddTail("", "");
}

function WCString &fbody() 
{ 
   if ( !$.BlockStack.Block$.Exists() ) 
      ParseError("Fatal Error: No blocks defined!",FATAL);

        if ( ! $.BlockStack.Block.fbody$.HasAttributes() ) {
                fbodyNewItem();
        }

        #Get very last item in the fbody list.
        CAttributeTree *pAttributes = $.BlockStack.Block.fbody$.GetAttributes(); 
        pAttributes->MoveLast();

        return pAttributes->GetCurrent()->GetValue();
}



////////////////////////////////////////////////////////////////////////////
// W17-12-95
//
// Start the creation of a new routine - parameter is used in routine name
//
// If no parameter given, Parse_Block#() is assumed, where # is a counter
//
function void Block_Up(char *aLabel)
{
   //Create new block on the stack
   $!BlockStack$.Push("Block");
   $.BlockStack.Block!fbody$;
   $.BlockStack.Block!FirstInFunction$.SetValue("-1");   //W9-4-97 IDIOT! Default == TRUE
  
   //Create function header
   if ( aLabel) {
      $.BlockStack.Block!Label$.SetValue(aLabel); //Label only given value if normal label, not internal block
   }
   else {
      ++m_BlockCount;

      //W9-4-97 Also save interim blocks in the attribute tree.
      WCString block("Block");
      block.AddInt(m_BlockCount);
      $.BlockStack.Block!count$.SetValue(block);
   }
}


////////////////////////////////////////////////////////////////////////////
// W17-12-95
//
// Send current block to output and flush its contents. Process previous block. 
//
// if m_BlockCount == -1, there are no blocks defined (empty block list)
//
function void Block_Down(void)
{
   if ( !$.BlockStack.Block$.Exists() ) 
      ParseError("Fatal Error: No blocks defined!",FATAL);
   
   //Flush all to output if Pass2
   WCString thisLabel = $.BlockStack.Block.Label$.GetValue(); //Label only given value if normal label, not internal block


   if ( thisLabel.Length() > 0 ) {
      //Labelname given; it's not an internal label
      if ( fconst().Length() )
         $.language.[gParserLanguage].Labels![thisLabel]!fconst$.SetValue( fconst() );

#      $.language.[gParserLanguage].Labels![thisLabel]!fbody$.SetValue( $.BlockStack.Block.fbody$.toString() );
      $.language.[gParserLanguage].Labels![thisLabel]!fbody$ = $.BlockStack.Block.fbody$;
   }
   else {
      //It must be an internal label
      if ( $.BlockStack.Block.count$.Exists() ) {
         thisLabel = $.BlockStack.Block.count$.GetValue();

         if ( fconst().Length() )
            $.language.[gParserLanguage]!InternalLabels![thisLabel]!fconst$.SetValue( fconst() );

#         $.language.[gParserLanguage]!InternalLabels![thisLabel]!fbody$.SetValue( $.BlockStack.Block.fbody$.toString() );
         $.language.[gParserLanguage]!InternalLabels![thisLabel]!fbody$ = $.BlockStack.Block.fbody$;
      }
      else
         ParseError("Undefined stuff on Block-stack",ERROR);
   }

   //Pop current block
   WCString dummy;
   $.BlockStack$.Pop(dummy);
}


function BOOL doSkipWS() 
{
        return gSkipWS;
}


////////////////////////////////////////////////////////////////////////////
// 7-4-97 The Final Check.
//
// Check if all the elements we have parsed and collected are suitable for
// output. In particular, the encountered labels are checked for 
// consistency.
//
// This function is called after the entire file has been parsed and before
// creation of output begins.
//
// If any errors are encountered, this function will generate a fatal error.
//
function BOOL DoFinalCheck()
{
   bool bFoundMissingLabels         = false;
   bool bFoundMissingFields         = false;
   bool bFoundMissingDefinition     = false;
   bool bFoundMissingImplementation = false;

   //Check if all encountered labels are defined
   $foreach pLang in .language$
   $body$
       gParserLanguage = pLang->GetName();
       WCString tempvalue;

      //
          // Check if definition and implementation parts of language have been defined.
          //
          if ( !$.language.[gParserLanguage].donedefinition$.Exists() ) {
                 WCString errstr("Definition part for language  ");
                 errstr << gParserLanguage << " has not been defined.";
                 ParseError(errstr,ERROR);
                 bFoundMissingDefinition = true;
          }

          if ( !$.language.[gParserLanguage].doneimplementation$.Exists() ) {
                 WCString errstr("Implementation part for language  ");
                 errstr << gParserLanguage << " has not been defined.";
                 ParseError(errstr,ERROR);
                 bFoundMissingImplementation = true;
          }

      //
      //Check rightlabels
      //
      $foreach pRightLabel in .language.[gParserLanguage].RightLabels$
      $body$
         tempvalue = pRightLabel->GetName();
         if ( !$.language.[gParserLanguage].Labels.[tempvalue]$.Exists() ) {
            WCString errstr("RightLabel \'");
            errstr << tempvalue << "\' has not been defined.";
            ParseError(errstr,ERROR);
            bFoundMissingLabels = true;
         }
      $end foreach$

      //
      //Check Action Labels
      //
      $foreach pActionLabel in .language.[gParserLanguage].ActionLabels$
      $body$
         tempvalue = pActionLabel->GetName();
         if ( !$.language.[gParserLanguage].Labels.[tempvalue]$.Exists() ) {
            WCString errstr("ActionLabel \'");
            errstr << tempvalue << "\' has not been defined.";
            ParseError(errstr,ERROR);
            bFoundMissingLabels = true;
         }
      $end foreach$

      //
      // Check if all labels have an fbody field.
      //
      $foreach pLabel in .language.[gParserLanguage].Labels$
      $body$
         if ( ! pLabel->Get("fbody").Exists() ) {
            WCString errstr("Field fbody does not exist for label ");
                        errstr += pLabel->GetName();
            ParseError(errstr,ERROR);
            bFoundMissingFields = true;
         }
      $end foreach$

   $end foreach$

    if (bFoundMissingLabels)
       return ParseError("Encountered undefined RightLabels and ActionLabels; bailing out.",FATAL);

    if (bFoundMissingFields)
       return ParseError("Encountered missing fconst and fbody fields; bailing out.",FATAL);

    if (bFoundMissingDefinition)
       return ParseError("Encountered missing definition part; bailing out.",FATAL);

    if (bFoundMissingImplementation)
       return ParseError("Encountered missing implementation part; bailing out.",FATAL);

    return TRUE;
}




function void DoFinalProcessing() 
{
   #Check for presence of create function
   $foreach pFunction in .language.[gParserLanguage].functions$
   $body$
      if ( pFunction->GetName() == "create()" ) {
                 #Move to outside functions list
                 $.language.[gParserLanguage]!specials!create$.SetValue(pFunction->GetValue());

                 $.language.[gParserLanguage].functions$.GetAttributes()->ClearCurrent();

                 ParseError( "Detected create() routine.", NOTE);
                 break;
                
          }
   $end foreach$


   #Check for presence of destroy function
   $foreach pFunction in .language.[gParserLanguage].functions$
   $body$
      if ( pFunction->GetName() == "destroy()" ) {
                 #Move to outside functions list
                 $.language.[gParserLanguage]!specials!destroy$.SetValue(pFunction->GetValue());

                 $.language.[gParserLanguage].functions$.GetAttributes()->ClearCurrent();

                 ParseError( "Detected destroy() routine.", NOTE);
                 break; 
                
          }
   $end foreach$
}

function void create() {
        //Empty for the time being
}



//
// End Language Definition.
//

}

#Following doesn't work any more!!!
#using language file insertmain.txt.



